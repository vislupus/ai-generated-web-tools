<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SheetClone</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }

        .cell {
            border-right: 1px solid #e2e8f0;
            border-bottom: 1px solid #e2e8f0;
            outline: none;
            overflow: hidden;
            padding: 0 4px;
            font-size: 13px;
            cursor: cell;
            user-select: none;
            display: flex;
            align-items: flex-end; 
            justify-content: flex-start;
            line-height: normal;
            position: relative;
            box-sizing: border-box;
            background: white;
        }

        /* Overlays Layer */
        #overlay-layer {
            pointer-events: none;
            z-index: 10;
        }

        /* Selection Overlay */
        #selection-overlay {
            pointer-events: none;
            position: absolute;
            border: 2px solid #107c41;
            z-index: 20; 
            display: none;
            box-shadow: 0 0 0 1px rgba(255,255,255,0.5) inset;
        }

        #selection-overlay.formula-mode {
            border: 2px dashed #f59e0b;
            background-color: rgba(245, 158, 11, 0.1);
            box-shadow: none;
        }

        #selection-handle {
            width: 8px;
            height: 8px;
            background: #107c41;
            position: absolute;
            bottom: -5px;
            right: -5px;
            border: 1px solid white;
            cursor: crosshair;
            pointer-events: auto;
        }
        
        #selection-overlay.formula-mode #selection-handle { background: #f59e0b; }

        #fill-overlay {
            pointer-events: none;
            position: absolute;
            z-index: 18;
            display: none;
            border: 1px dashed #666;
            background: rgba(0, 0, 0, 0.05);
        }

        /* Clipboard Overlay */
        #clipboard-overlay {
            pointer-events: none;
            position: absolute;
            z-index: 15;
            display: none;
            border: 2px dashed #2563eb;
            background: rgba(37, 99, 235, 0.05);
            animation: pulse-border 1s infinite;
        }
        @keyframes pulse-border {
            0% { opacity: 1; border-color: #2563eb; }
            50% { opacity: 0.5; border-color: #60a5fa; }
            100% { opacity: 1; border-color: #2563eb; }
        }

        /* Formula Highlights */
        .formula-highlight {
            position: absolute;
            pointer-events: none;
            z-index: 19;
            border-width: 2px;
            border-style: solid;
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Headers */
        .col-header, .row-header {
            background: #f8f9fa;
            font-weight: 600;
            color: #666;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            user-select: none;
        }
        .col-header { border-right: 1px solid #ccc; border-bottom: 1px solid #ccc; }
        .row-header { border-bottom: 1px solid #ccc; border-right: 1px solid #ccc; }
        
        .col-resizer { position: absolute; right: 0; top: 0; bottom: 0; width: 4px; cursor: col-resize; z-index: 20; }
        .col-resizer:hover { background: #107c41; }
        .row-resizer { position: absolute; left: 0; right: 0; bottom: 0; height: 4px; cursor: row-resize; z-index: 20; }
        .row-resizer:hover { background: #107c41; }

        /* Context Menu */
        #context-menu {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.2);
            z-index: 9999;
            display: none;
            flex-direction: column;
            padding: 4px 0;
            min-width: 150px;
        }
        .ctx-item { padding: 8px 16px; cursor: pointer; font-size: 13px; color: #333; }
        .ctx-item:hover { background-color: #f3f2f1; }
        .ctx-divider { height: 1px; background: #e0e0e0; margin: 4px 0; }

        /* Floating Editor */
        .floating-editor {
            position: absolute;
            border: 2px solid #107c41;
            background: white;
            z-index: 1000;
            font-family: inherit;
            font-size: inherit;
            padding: 0 2px;
            outline: none;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
            overflow: visible;
        }
        
        /* Charts */
        .chart-container {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1);
            padding: 0;
            resize: both;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            border-radius: 4px;
        }
        .chart-header { height: 32px; background: #f3f2f1; cursor: move; display: flex; justify-content: space-between; align-items: center; padding: 0 8px; border-bottom: 1px solid #e0e0e0; flex-shrink: 0; }
        .chart-title-input { border: 1px solid transparent; background: transparent; font-weight: 600; font-size: 13px; outline: none; flex-grow: 1; margin-right: 8px; padding: 2px 4px; border-radius: 2px; }
        .chart-title-input:focus { background: white; border-color: #107c41; }
        .chart-close-btn { color: #666; cursor: pointer; padding: 4px; border-radius: 4px; }
        .chart-close-btn:hover { background: #e0e0e0; color: #dc2626; }
        .chart-content { flex-grow: 1; position: relative; min-height: 0; padding: 8px; }
        .chart-axis-inputs { display: flex; gap: 8px; padding: 8px; background: #fafafa; border-top: 1px solid #e0e0e0; flex-shrink: 0; }
        .axis-title-input { border: 1px solid #ccc; padding: 4px 8px; font-size: 11px; outline: none; flex-grow: 1; border-radius: 2px; width: 0; }
        .axis-title-input:focus { border-color: #107c41; }
        
        /* UI Utils */
        .separator { height: 24px; width: 1px; background: #e0e0e0; margin: 0 6px; }
        .t-btn { padding: 4px; border-radius: 4px; color: #444; min-width: 28px; text-align: center; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .t-btn:hover { background-color: #f0f0f0; }
        
        .color-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; padding: 8px; width: 220px; }
        .color-swatch { width: 20px; height: 20px; border: 1px solid #e2e8f0; cursor: pointer; border-radius: 2px; }
        .color-swatch:hover { border-color: #000; transform: scale(1.1); }

        .dropdown-menu { position: absolute; top: 100%; left: 0; background: white; border: 1px solid #e5e7eb; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); z-index: 9999; border-radius: 4px; }
        .sheet-tab { padding: 4px 16px; cursor: pointer; border-right: 1px solid #ccc; background: #e2e8f0; font-size: 13px; display: flex; align-items: center; gap: 6px; }
        .sheet-tab.active { background: white; border-bottom: 2px solid #107c41; color: #107c41; font-weight: bold; }
    </style>
</head>
<body class="h-screen flex flex-col bg-white text-gray-800" oncontextmenu="return false;">

    <!-- TOOLBAR -->
    <div class="h-14 bg-[#f3f2f1] flex items-center px-4 border-b border-gray-300 gap-1 shrink-0 overflow-visible relative z-50">
        <div class="flex items-center gap-2 text-[#107c41] font-bold text-lg mr-4 select-none shrink-0">
            <i class="fas fa-table"></i> SheetClone
        </div>
        <div class="separator"></div>
        <button onclick="handleUndo()" class="t-btn" title="Undo"><i class="fas fa-undo"></i></button>
        <button onclick="handleRedo()" class="t-btn" title="Redo"><i class="fas fa-redo"></i></button>
        <button onclick="handleCut()" class="t-btn" title="Cut (Ctrl+X)"><i class="fas fa-cut"></i></button>
        <button onclick="handleCopy()" class="t-btn" title="Copy (Ctrl+C)"><i class="far fa-copy"></i></button>
        <button onclick="handlePaste()" class="t-btn" title="Paste (Ctrl+V)"><i class="far fa-clipboard"></i></button>
        <div class="separator"></div>
        <select id="fontFamily" onchange="setFontFamily(this.value)" class="h-6 text-xs border rounded px-1 outline-none w-24">
            <option value="Segoe UI">Segoe UI</option>
            <option value="Arial">Arial</option>
            <option value="Times New Roman">Times New Roman</option>
            <option value="Verdana">Verdana</option>
        </select>
        <select id="fontSize" onchange="setFontSize(this.value)" class="h-6 text-xs border rounded px-1 outline-none w-12">
            <option value="10">10</option>
            <option value="12">12</option>
            <option value="14">14</option>
            <option value="18">18</option>
            <option value="24">24</option>
        </select>
        <div class="separator"></div>
        <button onclick="toggleStyle('bold')" class="t-btn" title="Bold"><i class="fas fa-bold"></i></button>
        <button onclick="toggleStyle('italic')" class="t-btn" title="Italic"><i class="fas fa-italic"></i></button>
        <div class="relative group">
            <button class="t-btn" title="Text Color"><i class="fas fa-font text-red-600"></i></button>
            <div class="hidden group-hover:block dropdown-menu"><div class="color-grid" id="text-color-grid"></div></div>
        </div>
        <div class="relative group">
            <button class="t-btn" title="Fill Color"><i class="fas fa-fill-drip"></i></button>
            <div class="hidden group-hover:block dropdown-menu"><div class="color-grid" id="bg-color-grid"></div></div>
        </div>
        <div class="relative group">
            <button class="t-btn" title="Borders"><i class="fas fa-border-all"></i></button>
            <div class="hidden group-hover:flex flex-col dropdown-menu p-1 w-32">
                <div onclick="setBorder('all')" class="p-2 hover:bg-gray-100 cursor-pointer text-xs flex gap-2 items-center"><i class="fas fa-border-all"></i> All</div>
                <div onclick="setBorder('outer')" class="p-2 hover:bg-gray-100 cursor-pointer text-xs flex gap-2 items-center"><i class="far fa-square"></i> Outer</div>
                <div onclick="setBorder('none')" class="p-2 hover:bg-gray-100 cursor-pointer text-xs flex gap-2 items-center"><i class="fas fa-border-none"></i> None</div>
            </div>
        </div>
        <div class="separator"></div>
        <button onclick="toggleAlign('left')" class="t-btn"><i class="fas fa-align-left"></i></button>
        <button onclick="toggleAlign('center')" class="t-btn"><i class="fas fa-align-center"></i></button>
        <button onclick="toggleAlign('right')" class="t-btn"><i class="fas fa-align-right"></i></button>
        <div class="separator"></div>
        <button onclick="changeDecimals(-1)" class="t-btn w-8" title="Decrease Decimal"><i class="fas fa-minus text-[10px] mr-1"></i>.0</button>
        <button onclick="changeDecimals(1)" class="t-btn w-8" title="Increase Decimal"><i class="fas fa-plus text-[10px] mr-1"></i>.00</button>
        <div class="separator"></div>
        <div class="relative group">
            <button class="t-btn px-2 gap-1 text-xs font-semibold"><i class="fas fa-chart-bar text-blue-600"></i> Chart</button>
            <div class="hidden group-hover:flex flex-col dropdown-menu p-1 w-32">
                <div onclick="createChart('bar')" class="p-2 hover:bg-gray-100 cursor-pointer text-xs"><i class="fas fa-chart-bar mr-2"></i> Bar</div>
                <div onclick="createChart('line')" class="p-2 hover:bg-gray-100 cursor-pointer text-xs"><i class="fas fa-chart-line mr-2"></i> Line</div>
                <div onclick="createChart('scatter')" class="p-2 hover:bg-gray-100 cursor-pointer text-xs"><i class="fas fa-braille mr-2"></i> Scatter</div>
            </div>
        </div>
        <div class="separator"></div>
        <button onclick="mergeCells()" class="t-btn w-auto px-2 text-xs flex items-center gap-1" title="Merge Cells"><i class="fas fa-object-group"></i> Merge</button>
        <div class="separator"></div>
        <button onclick="handleDownload()" class="t-btn w-auto px-2 text-xs flex items-center gap-1"><i class="fas fa-download"></i> CSV</button>
        <label class="t-btn w-auto px-2 text-xs flex items-center gap-1 cursor-pointer"><i class="fas fa-upload"></i> Upload<input type="file" id="csvInput" accept=".csv" class="hidden" onchange="handleUpload(this)"></label>
        <button onclick="clearSheet()" class="t-btn w-auto px-2 text-xs flex items-center gap-1 hover:text-red-600"><i class="fas fa-trash"></i> Clear</button>
    </div>

    <div class="h-10 bg-white border-b border-gray-300 flex items-center px-2 shrink-0 relative z-40">
        <div id="active-cell-id" class="w-10 text-center text-gray-500 font-semibold text-sm border-r pr-2">A1</div>
        <div class="mx-2 text-gray-400"><i class="fas fa-function"></i></div>
        <input type="text" id="formula-input" class="flex-1 h-full outline-none text-sm px-2" placeholder="Enter value or formula (e.g. =SUM(A1:A5))">
    </div>

    <div class="flex-1 overflow-hidden relative flex flex-col z-0">
        <div class="flex overflow-hidden bg-[#f8f9fa] border-b border-gray-300 h-[26px]" id="col-header-container" style="margin-left: 40px;"></div>
        <div class="flex flex-1 overflow-auto relative" id="grid-scroll-area" onscroll="syncScroll()">
            <div class="w-[40px] bg-[#f8f9fa] border-r border-gray-300 flex-shrink-0 sticky left-0 z-20" id="row-header-container"></div>
            
            <!-- Main Cells Container - Now RELATIVE block -->
            <div id="cells-container" class="relative bg-white" style="display: block;">
                
                <!-- Grid Layer - Actual Data Cells -->
                <div id="grid-layer" style="display: grid;"></div>

                <!-- Overlay Layer - Selection, Borders, Charts -->
                <div id="overlay-layer" class="absolute inset-0 pointer-events-none">
                    <div id="formula-highlights"></div>
                    <div id="clipboard-overlay"></div>
                    <div id="fill-overlay"></div>
                    <div id="selection-overlay"><div id="selection-handle" onmousedown="initFillDrag(event)"></div></div>
                    <div id="charts-layer" class="absolute inset-0 pointer-events-none overflow-visible" style="width: 0; height: 0;"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="bg-[#f3f2f1] border-t border-gray-300 shrink-0 flex flex-col relative z-50">
        <div class="h-8 flex items-end px-2 gap-1 select-none" id="sheet-tabs-container">
            <button onclick="addSheet()" class="w-8 h-full text-gray-600 hover:bg-gray-200 flex items-center justify-center font-bold text-lg">+</button>
        </div>
        <div id="status-bar" class="h-6 bg-white border-t border-gray-200 flex items-center justify-end px-4 text-xs text-gray-600 font-medium gap-4"></div>
    </div>

    <!-- CONTEXT MENU -->
    <div id="context-menu">
        <div class="ctx-item" onclick="ctxAction('insert')">Insert</div>
        <div class="ctx-item" onclick="ctxAction('delete')">Delete</div>
        <div class="ctx-divider"></div>
        <div class="ctx-item" onclick="ctxAction('resize')">Resize...</div>
    </div>

    <script>
        const ROWS = 100;
        const COLS = 26;
        const DEFAULT_COL_WIDTH = 80;
        const DEFAULT_ROW_HEIGHT = 24;
        const COLORS = ['#000000', '#434343', '#666666', '#999999', '#b7b7b7', '#cccccc', '#d9d9d9', '#ffffff', '#980000', '#ff0000', '#ff9900', '#ffff00', '#00ff00', '#00ffff', '#4a86e8', '#0000ff', '#9900ff', '#ff00ff', '#e6b8af', '#f4cccc', '#fce5cd', '#fff2cc', '#d9ead3', '#d0e0e3', '#c9daf8', '#cfe2f3', '#d9d2e9', '#ead1dc', '#dd7e6b', '#ea9999', '#f9cb9c', '#ffe599', '#b6d7a8', '#a2c4c9', '#a4c2f4', '#9fc5e8', '#b4a7d6', '#d5a6bd', '#274e13', '#1c4587'];
        const FORMULA_COLORS = ['#2563eb', '#dc2626', '#9333ea', '#16a34a', '#ea580c']; 

        let state = {
            sheets: { 'Sheet1': { data: createEmptySheetData(), charts: [] } },
            activeSheet: 'Sheet1',
            selectedRange: { start: {c:0, r:0}, end: {c:0, r:0} }, 
            activeCell: {c: 0, r: 0},
            isDragging: false,
            isFilling: false,
            fillRange: null,
            columnWidths: {},
            rowHeights: {},
            clipboard: null, 
            history: [],
            historyIndex: -1,
            chartZIndex: 100
        };

        let formulaSelection = { active: false, startIdx: 0, endIdx: 0, baseC: 0, baseR: 0, targetInput: null };
        let contextMenu = { visible: false, type: null, index: -1 }; 
        let chartInstances = {}; 

        for(let i=0; i<COLS; i++) state.columnWidths[i] = DEFAULT_COL_WIDTH;
        for(let i=0; i<ROWS; i++) state.rowHeights[i] = DEFAULT_ROW_HEIGHT;

        const gridLayer = document.getElementById('grid-layer');
        const cellsContainer = document.getElementById('cells-container');
        const colHeaderContainer = document.getElementById('col-header-container');
        const rowHeaderContainer = document.getElementById('row-header-container');
        const gridScrollArea = document.getElementById('grid-scroll-area');
        const selectionOverlay = document.getElementById('selection-overlay');
        const fillOverlay = document.getElementById('fill-overlay');
        const clipboardOverlay = document.getElementById('clipboard-overlay');
        const formulaHighlights = document.getElementById('formula-highlights');
        const formulaInput = document.getElementById('formula-input');
        const activeCellIdDisplay = document.getElementById('active-cell-id');
        const statusBar = document.getElementById('status-bar');
        const chartsLayer = document.getElementById('charts-layer');
        const ctxMenu = document.getElementById('context-menu');

        function createEmptySheetData() {
            const data = {};
            for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) data[`${c},${r}`] = { value: '', formula: '', style: {} };
            return data;
        }

        const toChar = (n) => String.fromCharCode(65 + n); 
        const toCoord = (id) => { 
            const colChar = id.match(/[A-Z]+/)[0];
            const rowNum = parseInt(id.match(/[0-9]+/)[0]);
            return { c: colChar.charCodeAt(0) - 65, r: rowNum - 1 };
        };
        const toId = (c, r) => `${toChar(c)}${r + 1}`; 
        
        function getCellData(c, r) { return state.sheets[state.activeSheet].data[`${c},${r}`] || { value: '', formula: '', style: {} }; }
        function setCellData(c, r, data) { const current = getCellData(c, r); state.sheets[state.activeSheet].data[`${c},${r}`] = { ...current, ...data }; }
        function getCurrentSheet() { return state.sheets[state.activeSheet]; }

        function addToHistory() {
            if (state.historyIndex < state.history.length - 1) state.history = state.history.slice(0, state.historyIndex + 1);
            if (state.history.length > 49) state.history.shift();
            state.history.push({ sheets: JSON.parse(JSON.stringify(state.sheets)), columnWidths: {...state.columnWidths}, rowHeights: {...state.rowHeights}, activeSheet: state.activeSheet });
            state.historyIndex = state.history.length - 1;
        }
        function handleUndo() { if (state.historyIndex > 0) { state.historyIndex--; restoreState(state.history[state.historyIndex]); } }
        function handleRedo() { if (state.historyIndex < state.history.length - 1) { state.historyIndex++; restoreState(state.history[state.historyIndex]); } }
        function restoreState(snapshot) {
            state.sheets = JSON.parse(JSON.stringify(snapshot.sheets));
            state.columnWidths = {...snapshot.columnWidths};
            state.rowHeights = {...snapshot.rowHeights};
            state.activeSheet = snapshot.activeSheet;
            init(); 
        }

        function init() {
            initColorPickers();
            if(state.history.length === 0) addToHistory();
            renderHeaders();
            renderGrid();
            renderTabs();
            renderCharts();
            setupEvents();
            selectCell(0, 0);
        }

        function initColorPickers() {
            const textGrid = document.getElementById('text-color-grid');
            const bgGrid = document.getElementById('bg-color-grid');
            const createSwatch = (c, type) => {
                const el = document.createElement('div'); el.className = 'color-swatch'; el.style.backgroundColor = c;
                el.onclick = () => type === 'text' ? setTextColor(c) : setBackground(c);
                return el;
            };
            textGrid.innerHTML = ''; bgGrid.innerHTML = '';
            COLORS.forEach(c => { textGrid.appendChild(createSwatch(c, 'text')); bgGrid.appendChild(createSwatch(c, 'bg')); });
            const trans = document.createElement('div'); trans.className = 'color-swatch';
            trans.style.background = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAIklEQVQIW2NkQAKrVq36zwjjgzjwqkJyx48fJ0wUhQmCGAAr/Rs99Y4sOAAAAABJRU5ErkJggg==)';
            trans.onclick = () => setBackground(''); bgGrid.appendChild(trans);
        }

        function renderHeaders() {
            colHeaderContainer.innerHTML = ''; rowHeaderContainer.innerHTML = '';
            let totalWidth = 0;
            for (let c = 0; c < COLS; c++) {
                const w = state.columnWidths[c] || DEFAULT_COL_WIDTH;
                const el = document.createElement('div'); el.className = 'col-header'; el.style.width = w + 'px'; el.style.minWidth = w + 'px'; el.textContent = toChar(c);
                
                const resizer = document.createElement('div'); resizer.className = 'col-resizer'; 
                resizer.onmousedown = (e) => initColResize(e, c);
                resizer.ondblclick = (e) => { e.stopPropagation(); showResizePrompt('col', c); }; // Add double click here too

                el.ondblclick = () => showResizePrompt('col', c); // Double click header
                el.oncontextmenu = (e) => { e.preventDefault(); showContextMenu(e, 'col', c); };

                el.appendChild(resizer); colHeaderContainer.appendChild(el); totalWidth += w;
            }
            // Update BOTH layers width
            cellsContainer.style.width = totalWidth + 'px';
            gridLayer.style.width = totalWidth + 'px';
            
            let totalHeight = 0;
            for (let r = 0; r < ROWS; r++) {
                const h = state.rowHeights[r] || DEFAULT_ROW_HEIGHT;
                const el = document.createElement('div'); el.className = 'row-header'; el.style.height = h + 'px'; el.textContent = r + 1;
                
                const resizer = document.createElement('div'); resizer.className = 'row-resizer'; 
                resizer.onmousedown = (e) => initRowResize(e, r);
                resizer.ondblclick = (e) => { e.stopPropagation(); showResizePrompt('row', r); };

                el.ondblclick = () => showResizePrompt('row', r); // Double click header
                el.oncontextmenu = (e) => { e.preventDefault(); showContextMenu(e, 'row', r); };

                el.appendChild(resizer); rowHeaderContainer.appendChild(el); totalHeight += h;
            }
            // Update BOTH layers height
            cellsContainer.style.height = totalHeight + 'px';
            gridLayer.style.height = totalHeight + 'px';
        }

        function renderGrid() {
            // Clear grid-layer
            gridLayer.innerHTML = '';
            
            gridLayer.style.display = 'grid';
            let colTemplate = ''; for(let c=0; c<COLS; c++) colTemplate += `${state.columnWidths[c] || DEFAULT_COL_WIDTH}px `;
            gridLayer.style.gridTemplateColumns = colTemplate;
            let rowTemplate = ''; for(let r=0; r<ROWS; r++) rowTemplate += `${state.rowHeights[r] || DEFAULT_ROW_HEIGHT}px `;
            gridLayer.style.gridTemplateRows = rowTemplate;

            const fragment = document.createDocumentFragment();
            const sheetData = getCurrentSheet().data;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cellData = sheetData[`${c},${r}`] || { value: '', style: {} };
                    if (cellData.merged) continue;
                    const el = document.createElement('div'); el.className = 'cell'; el.dataset.c = c; el.dataset.r = r;
                    if (cellData.merge) { el.style.gridColumn = `span ${cellData.merge.colSpan || 1}`; el.style.gridRow = `span ${cellData.merge.rowSpan || 1}`; }
                    let displayVal = cellData.value;
                    const style = cellData.style || {};
                    if(style.decimals !== undefined && !isNaN(Number(displayVal)) && displayVal !== '') displayVal = Number(displayVal).toFixed(style.decimals);
                    el.textContent = displayVal;
                    if(String(cellData.value).startsWith('#')) el.style.color = 'red';
                    if(style.bold) el.style.fontWeight = 'bold'; if(style.italic) el.style.fontStyle = 'italic';
                    if(style.bg) el.style.backgroundColor = style.bg; if(style.color) el.style.color = style.color;
                    if(style.fontFamily) el.style.fontFamily = style.fontFamily; if(style.fontSize) el.style.fontSize = style.fontSize + 'px';
                    if(style.align) el.style.justifyContent = style.align === 'left' ? 'flex-start' : (style.align === 'right' ? 'flex-end' : 'center');
                    if(style.valign) el.style.alignItems = style.valign;
                    if(style.borderTop) el.style.borderTop = '1px solid #000'; if(style.borderRight) el.style.borderRight = '1px solid #000';
                    if(style.borderBottom) el.style.borderBottom = '1px solid #000'; if(style.borderLeft) el.style.borderLeft = '1px solid #000';
                    
                    // Attach events to grid cells
                    el.onmousedown = (e) => handleCellMouseDown(e, c, r); 
                    el.onmouseover = (e) => handleCellMouseOver(e, c, r); 
                    el.ondblclick = () => editCell(c, r);
                    fragment.appendChild(el);
                }
            }
            gridLayer.appendChild(fragment);
        }

        /* CONTEXT MENU */
        function showContextMenu(e, type, index) {
            contextMenu = { visible: true, type, index };
            ctxMenu.style.display = 'flex';
            ctxMenu.style.left = e.pageX + 'px';
            ctxMenu.style.top = e.pageY + 'px';
        }
        document.addEventListener('click', () => {
            if (contextMenu.visible) {
                ctxMenu.style.display = 'none';
                contextMenu.visible = false;
            }
        });
        function showResizePrompt(type, index) {
            const currentSize = type === 'col' ? (state.columnWidths[index]||DEFAULT_COL_WIDTH) : (state.rowHeights[index]||DEFAULT_ROW_HEIGHT);
            const newSize = prompt(`Enter new ${type==='col'?'width':'height'} (pixels):`, currentSize);
            if(newSize && !isNaN(newSize)) {
                addToHistory();
                if(type==='col') state.columnWidths[index] = Number(newSize);
                else state.rowHeights[index] = Number(newSize);
                renderHeaders();
                renderGrid();
                updateSelectionUI();
            }
        }
        function ctxAction(action) {
            addToHistory();
            const { type, index } = contextMenu;
            if (action === 'resize') {
                showResizePrompt(type, index);
            } else if (action === 'delete') {
                const sheet = state.sheets[state.activeSheet];
                const newData = {};
                Object.keys(sheet.data).forEach(key => {
                    const [c, r] = key.split(',').map(Number);
                    if (type === 'col') {
                        if (c < index) newData[key] = sheet.data[key];
                        else if (c > index) newData[`${c-1},${r}`] = sheet.data[key];
                    } else {
                        if (r < index) newData[key] = sheet.data[key];
                        else if (r > index) newData[`${c},${r-1}`] = sheet.data[key];
                    }
                });
                sheet.data = newData;
                if (type === 'col') { for(let i=index; i<COLS-1; i++) state.columnWidths[i] = state.columnWidths[i+1] || DEFAULT_COL_WIDTH; } 
                else { for(let i=index; i<ROWS-1; i++) state.rowHeights[i] = state.rowHeights[i+1] || DEFAULT_ROW_HEIGHT; }
            } else if (action === 'insert') {
                const sheet = state.sheets[state.activeSheet];
                const newData = {};
                Object.keys(sheet.data).forEach(key => {
                    const [c, r] = key.split(',').map(Number);
                    if (type === 'col') {
                        if (c < index) newData[key] = sheet.data[key];
                        else newData[`${c+1},${r}`] = sheet.data[key];
                    } else {
                        if (r < index) newData[key] = sheet.data[key];
                        else newData[`${c},${r+1}`] = sheet.data[key];
                    }
                });
                sheet.data = newData;
                if (type === 'col') {
                    for(let i=COLS-1; i>index; i--) state.columnWidths[i] = state.columnWidths[i-1] || DEFAULT_COL_WIDTH;
                    state.columnWidths[index] = DEFAULT_COL_WIDTH;
                } else {
                    for(let i=ROWS-1; i>index; i--) state.rowHeights[i] = state.rowHeights[i-1] || DEFAULT_ROW_HEIGHT;
                    state.rowHeights[index] = DEFAULT_ROW_HEIGHT;
                }
            }
            renderHeaders();
            renderGrid();
        }

        function initFillDrag(e) {
            e.stopPropagation(); e.preventDefault();
            state.isFilling = true; state.fillRange = { ...state.selectedRange };
        }

        function handleCellMouseDown(e, c, r) {
            const activeEl = document.activeElement;
            const isInput = activeEl === formulaInput || activeEl.classList.contains('floating-editor');
            if (isInput && activeEl.value.startsWith('=')) {
                e.preventDefault();
                formulaSelection = { active: true, startIdx: activeEl.selectionStart, endIdx: activeEl.selectionStart, baseC: c, baseR: r, targetInput: activeEl };
                const val = activeEl.value; const ref = toId(c, r);
                activeEl.value = val.substring(0, activeEl.selectionStart) + ref + val.substring(activeEl.selectionEnd);
                formulaSelection.endIdx += ref.length;
                state.selectedRange = { start: {c,r}, end: {c,r} }; 
                updateSelectionUI();
                renderFormulaHighlights(activeEl.value); 
                return;
            }
            state.isDragging = true; selectCell(c, r);
        }

        function handleCellMouseOver(e, c, r) {
            if (state.isFilling) {
                const s = state.selectedRange.start; const end = state.selectedRange.end;
                const origMaxC = Math.max(s.c, end.c), origMaxR = Math.max(s.r, end.r);
                const dR = r - origMaxR, dC = c - origMaxC;
                let newFillRange = { start: {c: Math.min(s.c,end.c), r: Math.min(s.r,end.r)}, end: {c: origMaxC, r: origMaxR} };
                if (Math.abs(dR) >= Math.abs(dC)) { if (r > origMaxR) newFillRange.end.r = r; } else { if (c > origMaxC) newFillRange.end.c = c; }
                state.fillRange = newFillRange; updateSelectionUI();
            } else if (state.isDragging) {
                state.selectedRange.end = {c, r}; updateSelectionUI();
            } else if (formulaSelection.active) {
                state.selectedRange.end = {c,r}; updateSelectionUI();
                const sc = Math.min(formulaSelection.baseC, c), ec = Math.max(formulaSelection.baseC, c);
                const sr = Math.min(formulaSelection.baseR, r), er = Math.max(formulaSelection.baseR, r);
                const ref = (sc===ec && sr===er) ? toId(sc,sr) : `${toId(sc,sr)}:${toId(ec,er)}`;
                const inp = formulaSelection.targetInput; const val = inp.value;
                inp.value = val.substring(0, formulaSelection.startIdx) + ref + val.substring(formulaSelection.endIdx);
                formulaSelection.endIdx = formulaSelection.startIdx + ref.length;
                renderFormulaHighlights(inp.value);
            }
        }

        document.addEventListener('mouseup', () => {
            if (state.isFilling) { state.isFilling = false; performFill(); state.fillRange = null; updateSelectionUI(); }
            state.isDragging = false;
            if(formulaSelection.active) { 
                formulaSelection.active = false; 
                if(formulaSelection.targetInput) formulaSelection.targetInput.focus(); 
                selectionOverlay.classList.remove('formula-mode'); 
            }
        });

        formulaInput.addEventListener('input', (e) => renderFormulaHighlights(e.target.value));

        function renderFormulaHighlights(formula) {
            formulaHighlights.innerHTML = '';
            if(!formula || !formula.startsWith('=')) return;
            const regex = /([A-Z]+[0-9]+)(?::([A-Z]+[0-9]+))?/g;
            let match; let colorIdx = 0;
            while((match = regex.exec(formula)) !== null) {
                const s = toCoord(match[1]), e = toCoord(match[2] || match[1]);
                const c1 = Math.min(s.c, e.c), c2 = Math.max(s.c, e.c), r1 = Math.min(s.r, e.r), r2 = Math.max(s.r, e.r);
                let l=0; for(let i=0;i<c1;i++) l+=state.columnWidths[i]||DEFAULT_COL_WIDTH;
                let w=0; for(let i=c1;i<=c2;i++) w+=state.columnWidths[i]||DEFAULT_COL_WIDTH;
                let t=0; for(let i=0;i<r1;i++) t+=state.rowHeights[i]||DEFAULT_ROW_HEIGHT;
                let h=0; for(let i=r1;i<=r2;i++) h+=state.rowHeights[i]||DEFAULT_ROW_HEIGHT;
                const el = document.createElement('div'); el.className = 'formula-highlight';
                el.style.left = l+'px'; el.style.top = t+'px'; el.style.width = w+'px'; el.style.height = h+'px';
                el.style.borderColor = FORMULA_COLORS[colorIdx % FORMULA_COLORS.length];
                formulaHighlights.appendChild(el); colorIdx++;
            }
        }

        function performFill() {
            if (!state.fillRange) return;
            addToHistory();
            const s = state.selectedRange.start, e = state.selectedRange.end;
            const origMinC = Math.min(s.c, e.c), origMaxC = Math.max(s.c, e.c), origMinR = Math.min(s.r, e.r), origMaxR = Math.max(s.r, e.r);
            const targetMaxC = Math.max(state.fillRange.start.c, state.fillRange.end.c), targetMaxR = Math.max(state.fillRange.start.r, state.fillRange.end.r);
            if (targetMaxR > origMaxR) {
                for (let c = origMinC; c <= origMaxC; c++) {
                    let colData = []; for (let r = origMinR; r <= origMaxR; r++) colData.push(getCellData(c, r).value);
                    let isNum = colData.length > 1 && colData.every(v => !isNaN(Number(v)) && v !== '');
                    let step = isNum ? (Number(colData[colData.length-1]) - Number(colData[0])) / (colData.length - 1) : 0;
                    for (let tr = origMaxR + 1, k=1; tr <= targetMaxR; tr++, k++) {
                        let val = isNum ? Number(colData[colData.length-1]) + (step * k) : colData[(k-1) % colData.length];
                        setCellData(c, tr, { value: val, formula: '', style: {...getCellData(c, origMaxR).style} });
                    }
                }
            } else if (targetMaxC > origMaxC) {
                for (let r = origMinR; r <= origMaxR; r++) {
                    let rowData = []; for (let c = origMinC; c <= origMaxC; c++) rowData.push(getCellData(c, r).value);
                    let isNum = rowData.length > 1 && rowData.every(v => !isNaN(Number(v)) && v !== '');
                    let step = isNum ? (Number(rowData[rowData.length-1]) - Number(rowData[0])) / (rowData.length - 1) : 0;
                    for (let tc = origMaxC + 1, k=1; tc <= targetMaxC; tc++, k++) {
                        let val = isNum ? Number(rowData[rowData.length-1]) + (step * k) : rowData[(k-1) % rowData.length];
                        setCellData(tc, r, { value: val, formula: '', style: {...getCellData(origMaxC, r).style} });
                    }
                }
            }
            renderGrid(); recalcAll();
        }

        function selectCell(c, r) {
            state.activeCell = {c, r}; state.selectedRange = { start: {c, r}, end: {c, r} };
            updateSelectionUI();
            const data = getCellData(c, r); formulaInput.value = data.formula || data.value || ''; activeCellIdDisplay.textContent = toId(c, r);
            renderFormulaHighlights(formulaInput.value); 
        }

        function updateSelectionUI() {
            const s = state.selectedRange.start; const e = state.selectedRange.end;
            const sc=Math.min(s.c,e.c), ec=Math.max(s.c,e.c), sr=Math.min(s.r,e.r), er=Math.max(s.r,e.r);
            const getRect = (c1, c2, r1, r2) => {
                let l=0; for(let i=0;i<c1;i++) l+=state.columnWidths[i]||DEFAULT_COL_WIDTH;
                let w=0; for(let i=c1;i<=c2;i++) w+=state.columnWidths[i]||DEFAULT_COL_WIDTH;
                let t=0; for(let i=0;i<r1;i++) t+=state.rowHeights[i]||DEFAULT_ROW_HEIGHT;
                let h=0; for(let i=r1;i<=r2;i++) h+=state.rowHeights[i]||DEFAULT_ROW_HEIGHT;
                return {l, t, w, h};
            };
            const selRect = getRect(sc, ec, sr, er);
            selectionOverlay.style.display = 'block'; selectionOverlay.style.left = selRect.l+'px'; selectionOverlay.style.top = selRect.t+'px';
            selectionOverlay.style.width = selRect.w+'px'; selectionOverlay.style.height = selRect.h+'px';
            
            if(formulaSelection.active) selectionOverlay.classList.add('formula-mode'); else selectionOverlay.classList.remove('formula-mode');

            if (state.isFilling && state.fillRange) {
                const fs = state.fillRange.start, fe = state.fillRange.end;
                const fillRect = getRect(Math.min(fs.c,fe.c), Math.max(fs.c,fe.c), Math.min(fs.r,fe.r), Math.max(fs.r,fe.r));
                fillOverlay.style.display = 'block'; fillOverlay.style.left = fillRect.l+'px'; fillOverlay.style.top = fillRect.t+'px';
                fillOverlay.style.width = fillRect.w+'px'; fillOverlay.style.height = fillRect.h+'px';
            } else fillOverlay.style.display = 'none';

            if (state.clipboard) {
                const cs = state.clipboard.range.start, ce = state.clipboard.range.end;
                const clipRect = getRect(Math.min(cs.c,ce.c), Math.max(cs.c,ce.c), Math.min(cs.r,ce.r), Math.max(cs.r,ce.r));
                clipboardOverlay.style.display = 'block'; clipboardOverlay.style.left = clipRect.l+'px'; clipboardOverlay.style.top = clipRect.t+'px';
                clipboardOverlay.style.width = clipRect.w+'px'; clipboardOverlay.style.height = clipRect.h+'px';
            } else clipboardOverlay.style.display = 'none';

            document.querySelectorAll('.col-header').forEach((el,i) => { el.style.background = (i>=sc && i<=ec) ? '#d3e3fd' : '#f8f9fa'; el.style.color = (i>=sc && i<=ec) ? '#107c41' : '#666'; });
            document.querySelectorAll('.row-header').forEach((el,i) => { el.style.background = (i>=sr && i<=er) ? '#d3e3fd' : '#f8f9fa'; el.style.color = (i>=sr && i<=er) ? '#107c41' : '#666'; });
        }
        
        function initColResize(e, c) {
            e.stopPropagation(); let sx = e.pageX, sw = state.columnWidths[c] || DEFAULT_COL_WIDTH;
            const move = (ev) => { state.columnWidths[c] = Math.max(20, sw + ev.pageX - sx); renderHeaders(); renderGrid(); updateSelectionUI(); renderFormulaHighlights(formulaInput.value); };
            const up = () => { addToHistory(); document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', up); };
            document.addEventListener('mousemove', move); document.addEventListener('mouseup', up);
        }
        function initRowResize(e, r) {
            e.stopPropagation(); let sy = e.pageY, sh = state.rowHeights[r] || DEFAULT_ROW_HEIGHT;
            const move = (ev) => { state.rowHeights[r] = Math.max(20, sh + ev.pageY - sy); renderHeaders(); renderGrid(); updateSelectionUI(); renderFormulaHighlights(formulaInput.value); };
            const up = () => { addToHistory(); document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', up); };
            document.addEventListener('mousemove', move); document.addEventListener('mouseup', up);
        }
        function syncScroll() { colHeaderContainer.scrollLeft = gridScrollArea.scrollLeft; rowHeaderContainer.scrollTop = gridScrollArea.scrollTop; }

        function renderTabs() { 
             const container = document.getElementById('sheet-tabs-container'); while(container.children.length > 1) container.removeChild(container.lastChild);
             Object.keys(state.sheets).forEach(name => {
                 const btn = document.createElement('div'); btn.className = `sheet-tab ${name === state.activeSheet ? 'active' : ''}`;
                 btn.textContent = name; btn.onclick = () => { state.activeSheet = name; init(); }; container.appendChild(btn);
             });
        }
        function addSheet() { addToHistory(); const n = `Sheet${Object.keys(state.sheets).length+1}`; state.sheets[n]={data:createEmptySheetData(), charts:[]}; state.activeSheet=n; init(); }
        
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && (e.key === 'z' || e.key === 'Z')) { e.preventDefault(); if(e.shiftKey) handleRedo(); else handleUndo(); return; }
            if (e.ctrlKey && (e.key === 'y' || e.key === 'Y')) { e.preventDefault(); handleRedo(); return; }
            if (e.ctrlKey && (e.key === 'x' || e.key === 'X')) { e.preventDefault(); handleCut(); return; }
            if (e.ctrlKey && (e.key === 'c' || e.key === 'C')) { e.preventDefault(); handleCopy(); return; }
            if (e.ctrlKey && (e.key === 'v' || e.key === 'V')) { e.preventDefault(); handlePaste(); return; }
            if(e.target.tagName === 'INPUT') return;
            const {c,r} = state.activeCell;
            if(e.key.startsWith('Arrow')) {
                e.preventDefault();
                const nc = c + (e.key==='ArrowRight'?1:(e.key==='ArrowLeft'?-1:0)); const nr = r + (e.key==='ArrowDown'?1:(e.key==='ArrowUp'?-1:0));
                if(nc>=0 && nc<COLS && nr>=0 && nr<ROWS) selectCell(nc, nr);
            } else if(e.key === 'Delete') {
                addToHistory(); const s=state.selectedRange.start, en=state.selectedRange.end;
                for(let i=Math.min(s.c,en.c); i<=Math.max(s.c,en.c); i++) for(let j=Math.min(s.r,en.r); j<=Math.max(s.r,en.r); j++) setCellData(i,j,{value:'',formula:''});
                recalcAll();
            } else if(e.key.length===1 && !e.ctrlKey) editCell(c,r);
        });

        function setupEvents() { cellsContainer.ondragstart = () => false; }
        
        function mergeCells() {
            addToHistory();
            const s = state.selectedRange.start; const e = state.selectedRange.end;
            const startC = Math.min(s.c, e.c), endC = Math.max(s.c, e.c), startR = Math.min(s.r, e.r), endR = Math.max(s.r, e.r);
            const topLeft = getCellData(startC, startR);
            if (topLeft.merge && topLeft.merge.colSpan === (endC-startC+1) && topLeft.merge.rowSpan === (endR-startR+1)) {
                topLeft.merge = null; setCellData(startC, startR, { merge: null });
                for(let i = startC; i <= endC; i++) for(let j = startR; j <= endR; j++) if(i!==startC || j!==startR) setCellData(i, j, { merged: false });
            } else {
                setCellData(startC, startR, { merge: { colSpan: endC-startC+1, rowSpan: endR-startR+1 } });
                for(let i = startC; i <= endC; i++) for(let j = startR; j <= endR; j++) if(i!==startC || j!==startR) setCellData(i, j, { merged: true }); 
            }
            renderGrid();
        }
        function handleCopy() {
            const s = state.selectedRange.start; const e = state.selectedRange.end;
            const copyData = [];
            for(let r = Math.min(s.r, e.r); r <= Math.max(s.r, e.r); r++) {
                const row = []; for(let c = Math.min(s.c, e.c); c <= Math.max(s.c, e.c); c++) row.push(JSON.parse(JSON.stringify(getCellData(c, r))));
                copyData.push(row);
            }
            state.clipboard = { type: 'copy', range: { start: s, end: e }, data: copyData }; updateSelectionUI();
        }
        function handleCut() {
            const s = state.selectedRange.start; const e = state.selectedRange.end;
            const copyData = [];
            for(let r = Math.min(s.r, e.r); r <= Math.max(s.r, e.r); r++) {
                const row = []; for(let c = Math.min(s.c, e.c); c <= Math.max(s.c, e.c); c++) row.push(JSON.parse(JSON.stringify(getCellData(c, r))));
                copyData.push(row);
            }
            state.clipboard = { type: 'cut', range: { start: s, end: e }, data: copyData }; updateSelectionUI();
        }
        function handlePaste() {
            if (!state.clipboard) return;
            addToHistory();
            const {c, r} = state.activeCell; const data = state.clipboard.data;
            data.forEach((row, rOffset) => {
                row.forEach((cellData, cOffset) => {
                    const targetC = c + cOffset; const targetR = r + rOffset;
                    if(targetC < COLS && targetR < ROWS) setCellData(targetC, targetR, { value: cellData.value, formula: cellData.formula, style: cellData.style });
                });
            });
            if (state.clipboard.type === 'cut') {
                const s = state.clipboard.range.start; const e = state.clipboard.range.end;
                for(let i = Math.min(s.c, e.c); i <= Math.max(s.c, e.c); i++) for(let j = Math.min(s.r, e.r); j <= Math.max(s.r, e.r); j++) setCellData(i, j, { value: '', formula: '', style: {} });
                state.clipboard = null;
            }
            renderGrid(); recalcAll(); updateSelectionUI();
        }
        
        function handleDownload() {
            const rows = []; const sheetData = getCurrentSheet().data;
            let maxR = 0, maxC = 0;
            Object.keys(sheetData).forEach(key => { const [c, r] = key.split(',').map(Number); if(sheetData[key].value!=='') { if(r>maxR) maxR=r; if(c>maxC) maxC=c; } });
            for(let r=0; r<=maxR; r++) {
                const rowData = [];
                for(let c=0; c<=maxC; c++) { let val = sheetData[`${c},${r}`]?.value || ''; val = String(val).replace(/"/g, '""'); if(val.includes(',')||val.includes('"')||val.includes('\n')) val = `"${val}"`; rowData.push(val); }
                rows.push(rowData.join(','));
            }
            const csvContent = "data:text/csv;charset=utf-8," + rows.join("\n"); const link = document.createElement("a");
            link.setAttribute("href", encodeURI(csvContent)); link.setAttribute("download", `${state.activeSheet}.csv`);
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
        }
        function handleUpload(input) {
            const file = input.files[0]; if(!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                addToHistory(); const rows = e.target.result.split('\n'); state.sheets[state.activeSheet].data = createEmptySheetData();
                rows.forEach((row, r) => { if(r>=ROWS) return; row.split(',').forEach((val, c) => { if(c>=COLS) return; val=val.trim().replace(/^"|"$/g,'').replace(/""/g,'"'); let num=Number(val); setCellData(c,r,{value:isNaN(num)||val===''?val:num}); }); });
                renderGrid();
            };
            reader.readAsText(file); input.value = ''; 
        }
        function clearSheet() { if(confirm('Clear?')) { addToHistory(); state.sheets[state.activeSheet].data = createEmptySheetData(); renderGrid(); selectCell(0,0); } }
        
        function renderCharts() {
            chartsLayer.innerHTML = ''; chartInstances = {}; const charts = getCurrentSheet().charts || [];
            charts.forEach((chartData, index) => {
                const wrapper = document.createElement('div'); wrapper.className = 'chart-container';
                wrapper.style.left = chartData.x + 'px'; wrapper.style.top = chartData.y + 'px'; wrapper.style.width = chartData.w + 'px'; wrapper.style.height = chartData.h + 'px';
                wrapper.style.zIndex = chartData.zIndex || 30; wrapper.style.pointerEvents = 'auto'; 
                wrapper.onmousedown = () => { state.chartZIndex++; wrapper.style.zIndex = state.chartZIndex; chartData.zIndex = state.chartZIndex; };
                const header = document.createElement('div'); header.className = 'chart-header';
                const titleInput = document.createElement('input'); titleInput.className = 'chart-title-input'; titleInput.value = chartData.title || 'Chart Title';
                titleInput.onmousedown = (e) => e.stopPropagation();
                titleInput.oninput = (e) => { chartData.title = e.target.value; if (chartInstances[index]) { chartInstances[index].options.plugins.title.text = chartData.title; chartInstances[index].update(); } };
                const closeBtn = document.createElement('i'); closeBtn.className = 'fas fa-times chart-close-btn';
                closeBtn.onmousedown = (e) => e.stopPropagation(); closeBtn.onclick = () => deleteChart(index);
                header.appendChild(titleInput); header.appendChild(closeBtn);
                header.onmousedown = (e) => {
                    e.preventDefault(); const startX = e.pageX - wrapper.offsetLeft, startY = e.pageY - wrapper.offsetTop;
                    state.chartZIndex++; wrapper.style.zIndex = state.chartZIndex; chartData.zIndex = state.chartZIndex;
                    const onMove = (ev) => { wrapper.style.left = (ev.pageX - startX) + 'px'; wrapper.style.top = (ev.pageY - startY) + 'px'; };
                    const onUp = () => { document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); chartData.x = parseInt(wrapper.style.left); chartData.y = parseInt(wrapper.style.top); };
                    document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp);
                };
                const content = document.createElement('div'); content.className = 'chart-content';
                const canvas = document.createElement('canvas'); content.appendChild(canvas);
                const axisInputs = document.createElement('div'); axisInputs.className = 'chart-axis-inputs';
                const xAxisInput = document.createElement('input'); xAxisInput.className = 'axis-title-input'; xAxisInput.placeholder = 'X Axis'; xAxisInput.value = chartData.xAxisTitle || '';
                xAxisInput.onmousedown = (e) => e.stopPropagation();
                xAxisInput.oninput = (e) => { chartData.xAxisTitle = e.target.value; if (chartInstances[index]) { chartInstances[index].options.scales.x.title.text = chartData.xAxisTitle; chartInstances[index].options.scales.x.title.display = !!chartData.xAxisTitle; chartInstances[index].update(); } };
                const yAxisInput = document.createElement('input'); yAxisInput.className = 'axis-title-input'; yAxisInput.placeholder = 'Y Axis'; yAxisInput.value = chartData.yAxisTitle || '';
                yAxisInput.onmousedown = (e) => e.stopPropagation();
                yAxisInput.oninput = (e) => { chartData.yAxisTitle = e.target.value; if (chartInstances[index]) { chartInstances[index].options.scales.y.title.text = chartData.yAxisTitle; chartInstances[index].options.scales.y.title.display = !!chartData.yAxisTitle; chartInstances[index].update(); } };
                axisInputs.appendChild(xAxisInput); axisInputs.appendChild(yAxisInput);
                wrapper.appendChild(header); wrapper.appendChild(content); wrapper.appendChild(axisInputs); chartsLayer.appendChild(wrapper);
                chartInstances[index] = new Chart(canvas, {
                    type: chartData.type, data: chartData.chartData,
                    options: { maintainAspectRatio: false, responsive: true, plugins: { title: { display: true, text: chartData.title }, legend: { position: 'bottom', labels: { boxWidth: 10, font: { size: 10 } } } }, scales: { x: { title: { display: !!chartData.xAxisTitle, text: chartData.xAxisTitle } }, y: { title: { display: !!chartData.yAxisTitle, text: chartData.yAxisTitle } } } }
                });
            });
        }
        function createChart(type) {
            const s = state.selectedRange.start, e = state.selectedRange.end;
            const startC = Math.min(s.c, e.c), endC = Math.max(s.c, e.c), startR = Math.min(s.r, e.r), endR = Math.max(s.r, e.r);
            const labels = []; const datasets = [];
            for(let r=startR; r<=endR; r++) labels.push(getCellData(startC, r).value || `Row ${r+1}`);
            for(let c=startC + (startC===endC ? 0 : 1); c<=endC; c++) {
                 const data = []; for(let r=startR; r<=endR; r++) data.push(Number(getCellData(c, r).value) || 0);
                 datasets.push({ label: `Series ${c+1}`, data: data, backgroundColor: type==='scatter'?'red':`hsl(${c*60},70%,50%)`, borderColor: `hsl(${c*60},70%,50%)`, borderWidth: 1 });
            }
            if (datasets.length === 0 && startC === endC) {
                const data = []; labels.length = 0;
                for(let r=startR; r<=endR; r++) { data.push(Number(getCellData(startC, r).value) || 0); labels.push(`R${r+1}`); }
                datasets.push({ label: 'Data', data: data, borderWidth: 1, backgroundColor: 'blue', borderColor: 'blue' });
            }
            if (type === 'scatter' && endC - startC === 1) {
                const scatterData = []; for(let r=startR; r<=endR; r++) scatterData.push({x: Number(getCellData(startC, r).value)||0, y: Number(getCellData(startC+1, r).value)||0});
                datasets[0] = { label: 'Scatter', data: scatterData, backgroundColor: 'red' }; datasets.length = 1;
            }
            addToHistory(); state.chartZIndex++;
            getCurrentSheet().charts.push({ type: type, x: 100, y: 100, w: 400, h: 300, zIndex: state.chartZIndex, title: 'New Chart', xAxisTitle: '', yAxisTitle: '', chartData: { labels, datasets } });
            renderCharts();
        }
        function deleteChart(index) { addToHistory(); getCurrentSheet().charts.splice(index, 1); renderCharts(); }

        function applyToSelection(cb) {
            addToHistory(); const s = state.selectedRange.start, e = state.selectedRange.end;
            for(let i = Math.min(s.c, e.c); i <= Math.max(s.c, e.c); i++) for(let j = Math.min(s.r, e.r); j <= Math.max(s.r, e.r); j++) {
                const curr = getCellData(i, j); const newStyle = { ...curr.style }; cb(newStyle); setCellData(i, j, { style: newStyle });
            }
            renderGrid();
        }
        function toggleStyle(type) { applyToSelection(s => s[type] = !s[type]); }
        function setBackground(c) { applyToSelection(s => s.bg = c); }
        function setTextColor(c) { applyToSelection(s => s.color = c); }
        function toggleAlign(a) { applyToSelection(s => s.align = a); }
        function setFontFamily(f) { applyToSelection(s => s.fontFamily = f); }
        function setFontSize(sz) { applyToSelection(s => s.fontSize = sz); }
        function setBorder(type) {
            applyToSelection((s) => { if (type === 'none') s.borderTop=s.borderRight=s.borderBottom=s.borderLeft=false; else if (type === 'all') s.borderTop=s.borderRight=s.borderBottom=s.borderLeft=true; });
            if (type === 'outer') {
                addToHistory(); const s = state.selectedRange.start, e = state.selectedRange.end;
                const minC = Math.min(s.c, e.c), maxC = Math.max(s.c, e.c), minR = Math.min(s.r, e.r), maxR = Math.max(s.r, e.r);
                for(let c=minC; c<=maxC; c++) { setCellData(c, minR, { style: {...getCellData(c, minR).style, borderTop: true} }); setCellData(c, maxR, { style: {...getCellData(c, maxR).style, borderBottom: true} }); }
                for(let r=minR; r<=maxR; r++) { setCellData(minC, r, { style: {...getCellData(minC, r).style, borderLeft: true} }); setCellData(maxC, r, { style: {...getCellData(maxC, r).style, borderRight: true} }); }
                renderGrid();
            }
        }
        function changeDecimals(delta) { applyToSelection(s => { let d = s.decimals !== undefined ? s.decimals : (s.decimals===undefined?2:0); d += delta; if (d < 0) d = 0; s.decimals = d; }); }

        function editCell(c, r) {
            let l=0; for(let i=0;i<c;i++) l+=state.columnWidths[i]||DEFAULT_COL_WIDTH;
            let t=0; for(let i=0;i<r;i++) t+=state.rowHeights[i]||DEFAULT_ROW_HEIGHT;
            const w=state.columnWidths[c]||DEFAULT_COL_WIDTH, h=state.rowHeights[r]||DEFAULT_ROW_HEIGHT;
            document.querySelectorAll('.floating-editor').forEach(el => el.remove());
            const data = getCellData(c, r);
            const input = document.createElement('input'); input.className = 'floating-editor'; input.value = data.formula || data.value;
            input.style.left = l+'px'; input.style.top = t+'px'; input.style.minWidth = w+'px'; input.style.height = h+'px';
            if(data.style.fontFamily) input.style.fontFamily = data.style.fontFamily; if(data.style.fontSize) input.style.fontSize = data.style.fontSize + 'px';
            cellsContainer.appendChild(input); input.focus();
            input.onblur = () => { commitCell(c, r, input.value); input.remove(); renderFormulaHighlights(''); };
            input.onkeydown = (e) => { if(e.key === 'Enter') { input.blur(); if(r < ROWS - 1) selectCell(c, r+1); } };
            input.addEventListener('input', () => { input.style.width = 'auto'; input.style.width = (input.scrollWidth + 10) + 'px'; renderFormulaHighlights(input.value); });
            renderFormulaHighlights(input.value); 
        }

        function commitCell(c, r, value) {
            addToHistory();
            let isFormula = value.toString().startsWith('=');
            let formula = isFormula ? value : '';
            let displayValue = value;
            let align = null;
            if (isFormula) { try { displayValue = evaluateFormula(value.substring(1)); } catch { displayValue = '#ERROR'; } }
            else {
                if(!isNaN(Number(value)) && value.trim() !== '') displayValue = Number(value);
                else {
                    const match = String(value).trim().match(/^(\d{1,2})[\./-](\d{1,2})[\./-](\d{2,4})$/);
                    if (match) { displayValue = `${match[1].padStart(2,'0')}.${match[2].padStart(2,'0')}.${match[3].length===2?'20'+match[3]:match[3]}`; align = 'right'; }
                }
            }
            const current = getCellData(c, r); const newStyle = {...current.style}; if(align) newStyle.align = align;
            setCellData(c, r, { value: displayValue, formula: formula, style: newStyle });
            renderGrid(); recalcAll();
        }

        function recalcAll() {
            let changes = 0; const sheetData = getCurrentSheet().data;
            for(let pass=0; pass<3; pass++) {
                for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) {
                    const d = sheetData[`${c},${r}`];
                    if(d && d.formula) { try { const nv = evaluateFormula(d.formula.substring(1)); if(nv !== d.value) { d.value = nv; changes++; } } catch { d.value = '#REF!'; } }
                }
                if(changes === 0) break;
            }
            renderGrid();
        }
        
        function evaluateFormula(exp) {
            const sheetData = getCurrentSheet().data;
            const getValue = (ref) => { const {c, r} = toCoord(ref); const val = sheetData[`${c},${r}`]?.value; return isNaN(Number(val)) ? 0 : Number(val); };
            exp = exp.replace(/([A-Z]+[0-9]+):([A-Z]+[0-9]+)/g, (match, start, end) => {
                const s = toCoord(start), e = toCoord(end); let vals = [];
                for(let r=Math.min(s.r,e.r); r<=Math.max(s.r,e.r); r++) for(let c=Math.min(s.c,e.c); c<=Math.max(s.c,e.c); c++) vals.push(sheetData[`${c},${r}`]?.value || 0);
                return `[${vals.join(',')}]`;
            });
            exp = exp.replace(/[A-Z]+[0-9]+/g, (match) => getValue(match));
            const arrSum = (...a) => a.flat().reduce((x,y)=>Number(x)+Number(y),0);
            const arrAvg = (...a) => { const f=a.flat(); return f.length?f.reduce((x,y)=>Number(x)+Number(y),0)/f.length:0; };
            const myMin = (...a) => { const f=a.flat(); return f.length?Math.min(...f):0; };
            const myMax = (...a) => { const f=a.flat(); return f.length?Math.max(...f):0; };
            exp = exp.replace(/SUM/g,'arrSum').replace(/AVERAGE/g,'arrAvg').replace(/MIN/g,'myMin').replace(/MAX/g,'myMax');
            try { return new Function('arrSum','arrAvg','myMin','myMax', `return (${exp})`)(arrSum,arrAvg,myMin,myMax); } catch { return '#ERROR'; }
        }

        init();
    </script>
</body>
</html>